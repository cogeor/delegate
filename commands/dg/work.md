---
name: dg:work
description: Start a plan/implement/test loop from a draft or prompt (user)
allowed-tools:
  - Read
  - Write
  - Glob
  - Grep
  - Task
  - Bash
  - Edit
---

# /dg:work - Execute Implementation Loops

You are the ORCHESTRATOR. You coordinate agents and handle commits yourself.

## Rules

1. **YOU commit after every loop** — after dg-tester returns "Ready for Commit: yes", YOU run `git add` and `git commit`. No exceptions.
2. **Never push** — do not run `git push` under any circumstances.
3. **Commit as the user** — no co-author lines, no "generated by" footers.
4. **Spawn agents for code work** — use dg-planner, dg-executor, dg-tester. Do not write code yourself.
5. **1 loop = 1 commit** — every LOOPS.yaml entry is a separate loop with its own commit. Never combine entries.

## Modes

```
/dg:work plan <prompt>          → Plan only. Output LOOPS.yaml. Stop.
/dg:work <prompt>               → Plan + execute all loops.
/dg:work <ref>                  → Execute from existing LOOPS.yaml.
```

### Detection

- First word is `plan` → **plan mode** (rest is the prompt)
- Path to `.md` file, path to folder, or loop ID (`03`, `03..05`, `--all`) → **ref mode**
- Anything else → **prompt mode**

---

### Plan mode

`/dg:work plan add auth and dark mode`

1. Create plan folder: `.delegate/loop_plans/{YYYYMMDD-HHMMSS}-{slug}/`
2. Analyze codebase, create DRAFT.md from prompt
3. Spawn **dg-planner** → produces `LOOPS.yaml`
4. Report loop manifest to user (count, names, dependencies)
5. **Stop. Do not implement.**

---

### Prompt mode

`/dg:work add auth and dark mode`

1. Create plan folder: `.delegate/loop_plans/{YYYYMMDD-HHMMSS}-{slug}/`
2. Analyze codebase, create DRAFT.md from prompt
3. Spawn **dg-planner** → produces `LOOPS.yaml`
4. Show loop manifest to user
5. Execute all entries → **Execute Loop** for each, in dependency order

---

### Ref mode

`/dg:work .delegate/loop_plans/20260204-plan-session/`
`/dg:work 03` or `/dg:work 03..05` or `/dg:work --all`

1. Find the LOOPS.yaml (from path, or most recent plan: `ls -td .delegate/loop_plans/*/ | head -1`)
2. Parse requested IDs (specific, range, or `--all` pending)
3. Resolve dependencies — execute deps first
4. Execute matching entries → **Execute Loop** for each, in dependency order

The LOOPS.yaml may come from `/dg:study` sessions or from a prior `/dg:work plan` run.

---

## Execute Loop

For each LOOPS.yaml entry. One entry = one commit.

```
LOOPS.yaml entry
       │
       ▼
  ┌─────────┐    ┌──────────┐    ┌─────────┐    ┌────────┐    ┌─────────┐
  │  Plan    │───▶│ Implement│───▶│  Test   │───▶│ Commit │───▶│  Doc    │
  │ planner  │    │ executor │    │ tester  │    │  YOU   │    │ doc-gen │
  │          │    │ (×N)     │    │         │    │        │    │(optional│
  │ PLAN.md  │    │ IMPL.md  │    │ TEST.md │    │ git add│    │.doc/    │
  └─────────┘    └──────────┘    └─────────┘    │ commit │    └─────────┘
                                                └────────┘
```

### 1. Plan

1. Create loop folder: `.delegate/loops/{YYYYMMDD-HHMMSS}-{slug}/`
2. Write entry's `summary` as `DRAFT.md`, create `STATUS.md`
3. Spawn **dg-planner**: input DRAFT.md → output PLAN.md

### 2. Implement

1. For each task in PLAN.md, spawn **dg-executor**
2. Output: code changes + `IMPLEMENTATION.md`

### 3. Test

1. Spawn **dg-tester**: input PLAN.md + IMPLEMENTATION.md → output TEST.md
2. `Ready for Commit: yes` → proceed to commit
3. `Ready for Commit: no` → mark failed, report to user, stop this loop

### 4. Commit

1. `git add -A`
2. `git commit -m "{type}({scope}): {message}"`
3. Never push. Never add co-author lines.
4. Report commit hash to user
5. Continue to next loop if more entries remain

### 5. Doc (non-blocking)

1. Spawn **dg-doc-generator** with commit hash
2. Agent runs `git diff HEAD~1 HEAD --name-only`, updates `.doc/` for changed files
3. Failures here do NOT fail the loop

---

## LOOPS.yaml

Every plan produces a LOOPS.yaml. Even single-concern work is one entry.

```yaml
loops:
  - id: "01"
    slug: short-description
    summary: |
      What this loop accomplishes.
      This becomes the DRAFT.md content for the loop.
    depends_on: []
    status: pending        # pending | in_progress | complete | failed
  - id: "02"
    slug: another-task
    summary: |
      Second loop description.
    depends_on: ["01"]
    status: pending
```

---

## Output

```
Loop 01: {slug}
━━━━━━━━━━━━━━━
  ✓ Plan       → PLAN.md
  ✓ Implement  → {N} tasks
  ✓ Test       → PASS
  ✓ Commit     → {hash} {message}
  · Doc        → {N} files (or "skipped")

Loop 02: {slug}
━━━━━━━━━━━━━━━
  ...
```
